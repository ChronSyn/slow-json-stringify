{"version":3,"file":"sjs.umd.js","sources":["../src/_utils.mjs","../src/sjs.mjs","../src/_dissectSchema.mjs","../src/_makeQueue.mjs"],"sourcesContent":["// Recursively building an array containing the path of a property in an object.\n// => e.g.\n//      const test = {\n//        a: {\n//          b: {\n//            c: 'test'\n//          }\n//        }\n//      }\n//      deepPath(test, 'c') // ['a', 'b', 'c']\nconst _deepPath = (obj, target) => {\n  for (const key in obj) {\n    if (key === target) return [key];\n    if (obj[key] && typeof obj[key] === 'object') {\n      const result = _deepPath(obj[key], target);\n      if (result) {\n        result.unshift(key);\n        return result;\n      }\n    }\n  }\n};\n\n// Reducing object to final value\nconst _deepFind = (obj, path) => path.reduce((a, b) => a && a[b], obj);\n\nconst _makeArr = (array, method) => {\n  if (method === 'array-simple') return JSON.stringify(array);\n\n  // Stringifying more complex array using the provided sjs schema\n  let acc = '';\n  for (const a of array) {\n    acc += method(a) + ',';\n  }\n\n  // Removing last comma.\n  return '[' + acc.substr(0, acc.length - 1) + ']';\n};\n\nexport {\n  _deepPath,\n  _deepFind,\n  _makeArr,\n};\n","import _dissectSchema from './_dissectSchema';\nimport _makeQueue from './_makeQueue';\nimport { _deepFind, _makeArr } from './_utils';\n\n// Doing a lot of preparation work before returning the final function responsible for\n// the stringification.\nconst sjs = (schema) => {\n  const { map, arrais, props, str } = _dissectSchema(schema);\n\n  // Building regex that match every prop => Used to enqueue props\n  // => So they will be picked in correct order when building final string.\n  const regex = new RegExp(`${props}\"(string|number|boolean)\"|\\\\[(.*?)\\\\]`, 'gm');\n\n  const { queue, chunks } = _makeQueue(str, regex);\n  const lastChunk = chunks[chunks.length - 1];\n\n  // Exposed function\n  return (obj) => {\n    let temp = '';\n    queue.forEach((e, i) => {\n      const raw = _deepFind(obj, map[e]);\n\n      // Arrais need a different treatment\n      // => This will make possible the stringification of an arbitrary number of arrais\n      const ready = arrais.has(e)\n        ? _makeArr(raw, arrais.get(e))\n        : raw;\n      temp += chunks[i] + ready;\n    });\n    return temp + lastChunk;\n  };\n};\n\nexport default sjs;\n","import { _deepPath } from './_utils';\n\nconst validator = (value) => {\n  // Declaring allowed types.\n  const allowedTypes = new Set(['number', 'string', 'boolean', 'array-simple', 'function']);\n\n  if (Array.isArray(value)) {\n    if (allowedTypes.has(value[0]) || allowedTypes.has(typeof value[0])) return;\n\n    // Throwing if inside array is found anything else than \"array-simple\" or new sjs schema\n    throw new Error(`Expected either \"array-simple\" or a function. received ${value}`);\n  } else if (typeof value !== 'function' && !allowedTypes.has(value)) {\n    // Throwing on illegal types\n    // => Mainly protecting users from typo.\n    throw new Error(`Expected one of: \"number\", \"string\", \"boolean\". received ${value}`);\n  }\n};\n\nexport default (schema) => {\n  // `map` will keep track of the paths of every nested prop\n  const map = {};\n\n  // `arrais` keep track of array properties and the method to be used when stringifying.\n  const arrais = new Map();\n\n  // Accumulator of every prop present in the schema\n  // => Used later to build a regex useful for queueing insertions.\n  let props = '';\n\n  // `str` in the end is simply the native stringification of schema.\n  // => JSON.stringify is used only for convenience.\n  const str = JSON.stringify(schema, (prop, value) => {\n    const isArray = Array.isArray(value);\n    if (typeof value !== 'object' || isArray) {\n      if (isArray) {\n        const current = value[0];\n        arrais.set(prop, current);\n      }\n\n      validator(value);\n\n      map[prop] = _deepPath(schema, prop);\n      props += `\"${prop}\"|`;\n    }\n    return value;\n  });\n\n  return { map, arrais, props, str };\n};\n","export default (str, regex) => {\n  const queue = [];\n\n  // Replacing types with a string that will make possible:\n  // - Inserting value without adding / removing additional charachters.\n  // - Split templated string in chunks for easier / faster insertion\n  const chunks = str\n    .replace(regex, (type) => {\n      switch (type) {\n        // returning __par__ enclosed by \"\"\n        // => When splitting there will be a \" on each side.\n        case '\"string\"':\n          return '\"__par__\"';\n\n        // When stringifying a function inside an array [null] is returned.\n        // => Using [null] as an identifier for array schema.\n        case '\"number\"':\n        case '\"boolean\"':\n        case '[\"array-simple\"]':\n        case '[null]':\n          return '__par__';\n        default:\n          // Pushing prop to queue => prop is enclosed by \"\" => matching before pushing\n          const prop = type.match(/(?<=\\\").+?(?=\\\")/)[0];\n          queue.push(prop);\n          return type;\n      }\n    })\n    .split('__par__');\n\n  return { queue, chunks };\n};\n"],"names":["const","_deepPath","obj","target","key","result","unshift","schema","map","arrais","Map","props","str","JSON","stringify","prop","value","isArray","Array","set","allowedTypes","Set","has","Error","validator","_dissectSchema","regex","queue","chunks","replace","type","match","push","split","_makeQueue","RegExp","lastChunk","length","temp","forEach","e","i","raw","path","reduce","a","b","_deepFind","ready","array","method","acc","substr","_makeArr","get"],"mappings":"gLAUAA,IAAMC,WAAaC,EAAKC,OACjBH,IAAMI,KAAOF,EAAK,IACjBE,IAAQD,EAAQ,MAAO,CAACC,MACxBF,EAAIE,IAA4B,iBAAbF,EAAIE,GAAmB,KACtCC,EAASJ,EAAUC,EAAIE,GAAMD,MAC/BE,SACFA,EAAOC,QAAQF,GACRC,qBCXFE,kBCYGA,OAERC,EAAM,GAGNC,EAAS,IAAIC,IAIfC,EAAQ,GAINC,EAAMC,KAAKC,UAAUP,WAASQ,EAAMC,OAClCC,EAAUC,MAAMD,QAAQD,UACT,iBAAVA,GAAsBC,KAC3BA,GAEFR,EAAOU,IAAIJ,EADKC,EAAM,aAjCXA,OAEXI,EAAe,IAAIC,IAAI,CAAC,SAAU,SAAU,UAAW,eAAgB,gBAEzEH,MAAMD,QAAQD,GAAQ,IACpBI,EAAaE,IAAIN,EAAM,KAAOI,EAAaE,WAAWN,EAAM,IAAK,aAG/D,IAAIO,gEAAgEP,GACrE,GAAqB,mBAAVA,IAAyBI,EAAaE,IAAIN,SAGpD,IAAIO,kEAAkEP,GAyB1EQ,CAAUR,GAEVR,EAAIO,GAAQd,EAAUM,EAAQQ,GAC9BJ,GAAU,IAAGI,QAERC,UAGF,KAAER,SAAKC,QAAQE,MAAOC,GDxCOa,CAAelB,iCEPrCK,EAAKc,OACbC,EAAQ,GAKRC,EAAShB,EACZiB,QAAQH,WAAQI,UACPA,OAGD,iBACI,gBAIJ,eACA,gBACA,uBACA,eACI,sBAGDf,EAAOe,EAAKC,MAAM,oBAAoB,UAC5CJ,EAAMK,KAAKjB,GACJe,KAGZG,MAAM,iBAEF,OAAEN,SAAOC,GFjBUM,OAFZ,IAAIC,uDAAwD,4BAGpEC,EAAYR,EAAOA,EAAOS,OAAS,mBAGjCnC,OACFoC,EAAO,UACXX,EAAMY,iBAASC,EAAGC,OACVC,WDIOxC,EAAKyC,UCJSnC,EAAIgC,GDICI,gBAAQC,EAAGC,UAAMD,GAAKA,EAAEC,IAAI5C,GCJhD6C,CAAU7C,GAIhB8C,EAAQvC,EAAOa,IAAIkB,YDEbS,EAAOC,MACR,iBAAXA,EAA2B,OAAOrC,KAAKC,UAAUmC,WAGjDE,EAAM,SACMF,kBACdE,GAAOD,QAAY,UAId,IAAMC,EAAIC,OAAO,EAAGD,EAAId,OAAS,GAAK,ICXrCgB,CAASX,EAAKjC,EAAO6C,IAAId,IACzBE,EACJJ,GAAQV,EAAOa,GAAKO,IAEfV,EAAOF"}